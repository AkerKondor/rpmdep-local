Инструкция для пользователя
Что необходимо:

    1. Операционная система от RH или Oracle (Mandriva/Mageia/Alt не проверены, но в них должно работать).
    2. Установленный пакет rpmorphan (текущая версия 1.19, проверены версии от 0.7 и новее).
    3. Для вывода картинки -- пакет Graphwiz
    4. Файл сценария buildcache.sh (из данной папки).
    5. Папка с файлами RPM, зависимости между которыми надо вычислить (плоская, без подпапок).

Порядок действий:

    1. Выполнить ./buildcache.sh /path/to/rpm/fileset/
    2. Выполнить (из-под обычного пользователя) "rpmdep -use-cache -dot mypack.dot mypack" для вывода зависимостей пакета mypack или "rpmdep -use-cache -dot all.dot -all" для вывода всех зависимостей между пакетами.
    3. Подобрать файл .dot из текущего каталога, это текстовый файл в удобном для работы формате, в нём граф зависимостей.
    4. Если нужна картинка, то выполнить "dot -Tsvg mypack.dot -o mypack.svg". Предупреждение: на all.svg стандартная линуксовая программа просмотра (evince) завершится аварийно, он слишком большой. dot -- программа из пакета Graphwiz.

При перезапуске buildcache.sh файл данных для rpmdep очищается.

Ограничения метода:
    1. Метод не реентерабелен и потому не может быть использован одновременно 2 или более пользователями на одной машине, нельзя также работать параллельно с зависимостями установленных и не установленных пакетов. Это я постараюсь исправить как можно быстрее. Вообще, по большому счёту, на это надо выставлять баг в RH.
    2. (Перепроверить!) В результате тщательного анализа кодов rpmdep.pl и библиотеки rpmorphan-lib.pl выясняется, что они написаны в расчёте на то, что capabilities (термин определён в документации по rpm5), выдаваемые в списке зависимостей пакета, можно преобразовать в имена пакетов (см. функцию is_package и её вызовы в rpmdep.pl), однако это верно только для пакетов, изначально сформированных в стандарте rpm4 и потом пересобранных в стандарте rpm5; из документации по rpm5 следует, что из имени capability имя пакета, её поставляющего, извлекаться не обязано. Это значит, что программа способна выдавать ошибки в виде, например, несуществующих имён пакетов (на примерах её работы, гуляющих по Интернету, они имеются).
    3. Кроме того, тип capability угадывается, а не анализируется, а версия capability и для требуемых, и для поставляемых сущностей просто отбрасывается без анализа.
    4. Метод непригоден для работы с не установленными в систему пакетами, лежащими в удалённом репозитории. (Как с ними работать, пока непонятно. Простым сценарием тут не обойтись.)
    5. Работать одновременно с установленными и локальными не установленными пакетами можно, выполнив слияние кэшей для первого и второго случаев, но я эту возможность пока не проверял. Для неё сценарий формирования кэша придётся слить из первого и второго фрагментов. 
